material {
    name : step4,
    shadingModel : lit,
    transparency: twoPassesTwoSides,
    blending: fade,
    culling: none,
    parameters : [
        { type : float3, name : baseColor },
        { type : float,  name : roughness },

        { type : float,  name : fadeInPolygon },

        { type : float,  name : clearCoat },
        { type : float,  name : clearCoatRoughness }
    ],
}

fragment {

    const float T = 0.01;
    const vec4 kLineColor = vec4(0.0, 0.0, 0.0, 1.0);


    float getEndcaps(vec4 wpos, vec4 planeA, vec4 planeB, float t) {
        planeA.w = T;
        planeB.w = T;
        float a = step(0.0, dot(wpos, planeA));
        planeB = normalize(mix(planeA, -planeB, t));
        float b = step(dot(wpos, planeB), 0.0);
        return a * b;
    }

    void material(inout MaterialInputs material) {
        prepareMaterial(material);
        material.baseColor.rgb = materialParams.baseColor;
        material.baseColor.b *= 0.5;
        material.baseColor.a = 1.0;

        vec4 wpos = vec4(getWorldPosition() + getWorldOffset(), 1.0);
        vec4 kPlaneA = vec4(normalize(vec3(-0.1, -0.7, +0.5)), 0.0);
        vec4 kPlaneB = vec4(normalize(vec3(+0.7, +0.7, +0.3)), 0.0);
        vec4 kPlaneC = vec4(normalize(vec3(-0.6, +0.6, +0.1)), 0.0);

        bool insideA = dot(wpos, kPlaneA) > 0.0;
        bool insideB = dot(wpos, kPlaneB) > 0.0;
        bool insideC = dot(wpos, kPlaneC) > 0.0;

        float fadeIn = materialParams.fadeInPolygon;
        float aDrawTime = clamp((fadeIn * 3.0 - 0.0), 0.0, 1.0);
        float bDrawTime = clamp((fadeIn * 3.0 - 1.0), 0.0, 1.0);
        float cDrawTime = clamp((fadeIn * 3.0 - 2.0), 0.0, 1.0);

        {
            float d1 = dot(wpos, vec4(kPlaneA.xyz, kPlaneA.w + T));
            float d2 = dot(wpos, vec4(kPlaneA.xyz, kPlaneA.w - T));
            float d3 = getEndcaps(wpos, kPlaneB, kPlaneC, aDrawTime);
            float a = step(d2, 0.0) * step(0.0, d1) * d3;
            material.baseColor = mix(material.baseColor, kLineColor, a);
        }

        {
            float d1 = dot(wpos, vec4(kPlaneB.xyz, kPlaneB.w + T));
            float d2 = dot(wpos, vec4(kPlaneB.xyz, kPlaneB.w - T));
            float d3 = getEndcaps(wpos, kPlaneA, kPlaneC, bDrawTime);
            float a = step(d2, 0.0) * step(0.0, d1) * d3;
            material.baseColor = mix(material.baseColor, kLineColor, a);
        }

        {
            float d1 = dot(wpos, vec4(kPlaneC.xyz, kPlaneC.w + T));
            float d2 = dot(wpos, vec4(kPlaneC.xyz, kPlaneC.w - T));
            float d3 = getEndcaps(wpos, kPlaneA, kPlaneB, cDrawTime);
            float a = step(d2, 0.0) * step(0.0, d1) * d3;
            material.baseColor = mix(material.baseColor, kLineColor, a);
        }

        // Dark filled area of triangle
        float alpha = (insideA && insideB && insideC) ? 0.5 : 1.0;
        material.baseColor.rgb *= mix(1.0, alpha, cDrawTime);

        material.roughness = materialParams.roughness;
        material.clearCoat = materialParams.clearCoat;
        material.clearCoatRoughness = materialParams.clearCoatRoughness;
    }
}