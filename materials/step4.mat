material {
    name : step4,
    shadingModel : lit,
    transparency: twoPassesTwoSides,
    blending: fade,
    culling: none,
    parameters : [
        { type : float3, name : baseColor },
        { type : float,  name : roughness },

        { type : float,  name : fadeInPolygon },

        { type : float,  name : clearCoat },
        { type : float,  name : clearCoatRoughness }
    ],
}

fragment {

    const float kLineThickness = 0.01;
    const vec4 kLineColor = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 rotate(vec4 pt, vec3 axis, float angle) {
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        return pt * mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                         oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                         oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                         0.0,                                0.0,                                0.0,                                1.0);
    }

    // Returns 0 or 1. The latter is returned only if the given point is both inside the half-space of planeA and inside
    // the reverse half-space of planeB. The given t value is a fraction in [0,1] used to animate planeB to create the
    // illusion that the line is being gradually inscribed.
    float between(vec4 pos, vec4 planeA, vec4 planeB, float t) {
        planeA.w = kLineThickness;
        planeB.w = kLineThickness;
        float a = step(0.0, dot(pos, planeA));
        planeB = normalize(mix(planeA, -planeB, t));
        float b = step(dot(pos, planeB), 0.0);
        return a * b;
    }

    // Returns a number in [0,1] where 0 is outside a thick geodesic line segment and 1 is inside. Fractional values may
    // be returned to achieve smooth antialiasing. The geodesic is defined as the intersection of a great circle with
    // two bounding half-spaces (lowerClip and upperClip). The great circle is the intersection of "plane" with the unit
    // sphere.
    //
    // To draw a thick lines, thick function splits "plane" into two planes by shifting it along its normal and checking
    // that the given point "pos" is between the shifted planes. The given t value is a fraction in [0,1] used to 
    // animate the bounding planes to create the illusion that the line is being gradually inscribed.
    float geodesic(vec4 pos, vec4 plane, vec4 lowerClip, vec4 upperClip, float t) {
        float d1 = dot(pos, vec4(plane.xyz, +kLineThickness));
        float d2 = dot(pos, vec4(plane.xyz, -kLineThickness));
        float d3 = between(pos, lowerClip, upperClip, t);
        return step(0.0, d1) * step(d2, 0.0) * d3;
    }

    void material(inout MaterialInputs material) {
        prepareMaterial(material);

        vec4 color = vec4(materialParams.baseColor, 1.0);
        color.b *= 0.5;

        vec4 wpos = vec4(getWorldPosition() + getWorldOffset(), 1.0);
        vec4 K = vec4(0, 0, 1, 0);
        float theta = 85.0 * PI / 180.0; // <== This angle determines how large the polygon is.

        float theta0 = 2.0 * PI * 0.0 / 3.0;
        float theta1 = 2.0 * PI * 1.0 / 3.0;
        float theta2 = 2.0 * PI * 2.0 / 3.0;

        vec4 kPlaneA = rotate(K, vec3(sin(theta0), cos(theta0), 0.0), theta);
        vec4 kPlaneB = rotate(K, vec3(sin(theta1), cos(theta1), 0.0), theta);
        vec4 kPlaneC = rotate(K, vec3(sin(theta2), cos(theta2), 0.0), theta);

        bool insideA = dot(wpos, kPlaneA) > 0.0;
        bool insideB = dot(wpos, kPlaneB) > 0.0;
        bool insideC = dot(wpos, kPlaneC) > 0.0;

        float fadeIn = materialParams.fadeInPolygon;
        float aDrawTime = clamp((fadeIn * 3.0 - 0.0), 0.0, 1.0);
        float bDrawTime = clamp((fadeIn * 3.0 - 1.0), 0.0, 1.0);
        float cDrawTime = clamp((fadeIn * 3.0 - 2.0), 0.0, 1.0);

        // Thick lines.
        color = mix(color, kLineColor, geodesic(wpos, kPlaneA, kPlaneB, kPlaneC, aDrawTime));
        color = mix(color, kLineColor, geodesic(wpos, kPlaneB, kPlaneA, kPlaneC, bDrawTime));
        color = mix(color, kLineColor, geodesic(wpos, kPlaneC, kPlaneA, kPlaneB, cDrawTime));

        // Dark filled area on the inside.
        color.rgb *= mix(1.0, (insideA && insideB && insideC) ? 0.5 : 1.0, cDrawTime);

        material.baseColor = color;
        material.roughness = materialParams.roughness;
        material.clearCoat = materialParams.clearCoat;
        material.clearCoatRoughness = materialParams.clearCoatRoughness;
    }
}