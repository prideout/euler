{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app.ts","webpack:///./src/scrollytell.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAsC;AAC/B;AACP;AACA;AACA,yBAAyB,kDAAK;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA,4CAA4C,sBAAsB;AAClE;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/app.ts\");\n","import { Story } from \"./scrollytell\";\nexport class App {\n    constructor() {\n        this.frame = 0;\n        this.story = new Story({\n            chartSelector: \".chart\",\n            containerSelector: \".container\",\n            fullsizeChart: true,\n            panelSelector: \".panel\",\n        });\n        this.tick = this.render.bind(this);\n        const checkbox = document.getElementById(\"show_hud\");\n        const canvas2d = document.getElementById(\"canvas2d\");\n        const canvas3d = document.getElementById(\"canvas3d\");\n        checkbox.addEventListener(\"click\", () => {\n            this.story.showDeveloperHud(checkbox.checked);\n        });\n        const dpr = window.devicePixelRatio;\n        const width = canvas2d.clientWidth * dpr;\n        const height = canvas2d.clientHeight * dpr;\n        this.width = canvas3d.width = canvas2d.width = width;\n        this.height = canvas3d.height = canvas2d.height = height;\n        this.context2d = canvas2d.getContext(\"2d\");\n        this.context2d.lineWidth = 3;\n        window.requestAnimationFrame(this.tick);\n    }\n    render() {\n        const t = this.frame * 0.05;\n        const x0 = this.width / 2 - Math.sin(t) * this.width / 2;\n        const x1 = this.width / 2 + Math.sin(t) * this.width / 2;\n        this.context2d.clearRect(0, 0, this.width, this.height);\n        this.context2d.beginPath();\n        this.context2d.moveTo(x1, 0);\n        this.context2d.lineTo(x0, this.height);\n        this.context2d.moveTo(x1, this.height);\n        this.context2d.lineTo(x0, 0);\n        this.context2d.stroke();\n        this.frame += 1;\n        window.requestAnimationFrame(this.tick);\n    }\n}\nwindow.onload = () => {\n    // tslint:disable-next-line: no-string-literal\n    window[\"app\"] = new App();\n};\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n/**\n * The context for all animation corresponding to a container element.\n */\nexport class Story {\n    constructor(config) {\n        this.config = config;\n        this.activePanelIndex = -1;\n        this.progressValue = -1;\n        this.frameCount = 0;\n        this.container = document.querySelector(config.containerSelector);\n        if (!this.container) {\n            throw Error(\"Scrollytell container not found.\");\n        }\n        const cstyle = window.getComputedStyle(this.container);\n        if (cstyle.getPropertyValue(\"overflow-y\") !== \"scroll\") {\n            throw Error(\"Scrollytell container must have overflow-y:scroll.\");\n        }\n        if (cstyle.getPropertyValue(\"position\") !== \"relative\") {\n            throw Error(\"Scrollytell container must have position:relative.\");\n        }\n        this.panels = document.querySelectorAll(config.panelSelector);\n        if (!this.panels) {\n            throw Error(\"Scrollytell panels not found.\");\n        }\n        this.chart = document.querySelector(config.chartSelector);\n        if (config.fullsizeChart && !this.chart) {\n            throw Error(\"Scrollytell chart not found.\");\n        }\n        if (config.fullsizeChart) {\n            const height = this.container.getBoundingClientRect().height;\n            this.chart.style.height = `${height}px`;\n            this.chart.style.top = \"0\";\n            const segments = document.querySelectorAll(\"segmenty\");\n            for (const segment of segments) {\n                segment.style.height = `${height}px`;\n            }\n        }\n        if (config.developerHud) {\n            this.showDeveloperHud(true);\n        }\n        this.tick = this.render.bind(this);\n        window.requestAnimationFrame(this.tick);\n    }\n    /**\n     * Returns the zero-based index of the panel that is currently overlapping\n     * the guideline. Returns -1 if no such panel exists.\n     */\n    getActivePanelIndex() {\n        return this.activePanelIndex;\n    }\n    /**\n     * Returns a percentage in the range [0, 1] that represents the position of\n     * the active panel relative to the guideline. Returns 0 when the top of the\n     * panel aligns with the guideline, +1 when the bottom of the panel aligns\n     * with the guideline, and -1 if no panel is overlapping the guideline.\n     */\n    getProgressValue() {\n        return this.progressValue;\n    }\n    /**\n     * Toggles the heads-up-display for development purposes. Do not enable\n     * when your site is in production.\n     */\n    showDeveloperHud(enable) {\n        if (this.developerHudCanvas) {\n            const visibility = enable ? \"visible\" : \"hidden\";\n            this.developerHudCanvas.style.visibility = visibility;\n            return;\n        }\n        if (!enable) {\n            return;\n        }\n        const canvas = document.createElement(\"canvas\");\n        const style = canvas.style;\n        style.position = \"fixed\";\n        style.width = \"100%\";\n        style.height = \"100%\";\n        style.left = \"0\";\n        style.top = \"0\";\n        style.zIndex = \"100\";\n        style.pointerEvents = \"none\";\n        this.container.appendChild(canvas);\n        const dpr = window.devicePixelRatio;\n        canvas.width = canvas.clientWidth * dpr;\n        canvas.height = canvas.clientHeight * dpr;\n        this.developerHudContext = canvas.getContext(\"2d\");\n        this.developerHudContext.scale(dpr, dpr);\n        this.developerHudCanvas = canvas;\n        const family = \"'Lexend Deca', sans-serif\";\n        this.developerHudContext.font = `bold 14px ${family}`;\n        // Force a redraw on the next frame.\n        this.scrollTop = undefined;\n    }\n    render() {\n        // Take care not to do work if no scrolling has occurred. This is an\n        // important optimization because it can save power on mobile devices.\n        const scrollTop = this.container.scrollTop;\n        if (scrollTop === this.scrollTop) {\n            window.requestAnimationFrame(this.tick);\n            return;\n        }\n        this.scrollTop = scrollTop;\n        // Determine the guideline Y coordinate.\n        const cbox = this.container.getBoundingClientRect();\n        const guideline = (cbox.top + cbox.bottom) / 2;\n        // Determine the active panel and progress value.\n        const prevActivePanel = this.activePanelIndex;\n        const prevProgressValue = this.progressValue;\n        this.activePanelIndex = -1;\n        this.progressValue = -1;\n        for (const [index, panel] of this.panels.entries()) {\n            const pbox = panel.getBoundingClientRect();\n            const outside = pbox.top > guideline || pbox.bottom < guideline;\n            const active = !outside;\n            const ratio = (guideline - pbox.top) / pbox.height;\n            if (active) {\n                this.activePanelIndex = index;\n                this.progressValue = ratio;\n                break;\n            }\n        }\n        const panelChanged = prevActivePanel !== this.activePanelIndex;\n        const progressChanged = prevProgressValue !== this.progressValue;\n        // Trigger scrollytelling events.\n        if (panelChanged) {\n            if (this.config.exitHandler) {\n                this.config.exitHandler(this, prevActivePanel);\n            }\n            if (this.config.enterHandler) {\n                this.config.enterHandler(this, this.activePanelIndex);\n            }\n        }\n        // Do not update the frame count when scrolling between panels (i.e.\n        // when there is no active panel).\n        if (progressChanged || panelChanged) {\n            this.frameCount += 1;\n            if (this.config.progressHandler) {\n                this.config.progressHandler(this, this.progressValue);\n            }\n        }\n        // Render the developer HUD even when the frame count has not been\n        // incremented (i.e. activePanelIndex == -1) because the relative\n        // position of the panel bounding / boxes may have changed.\n        if (this.developerHudContext) {\n            this.renderDeveloperHud(cbox);\n        }\n        window.requestAnimationFrame(this.tick);\n    }\n    renderDeveloperHud(containerBox) {\n        const cbox = containerBox;\n        const ctx = this.developerHudContext;\n        const guideline = (cbox.top + cbox.bottom) / 2;\n        const width = this.developerHudCanvas.width;\n        const height = this.developerHudCanvas.height;\n        // Make the canvas transparent before drawing anything.\n        ctx.clearRect(0, 0, width, height);\n        // Draw semitransparent gray rectangles over each panel.\n        ctx.beginPath();\n        ctx.fillStyle = \"rgba(128, 128, 128, 0.125)\";\n        for (const [index, panel] of this.panels.entries()) {\n            const pbox = panel.getBoundingClientRect();\n            ctx.rect(pbox.left, pbox.top, pbox.width, pbox.height);\n        }\n        ctx.fill();\n        // Draw a semitransparent white background rect under the text.\n        ctx.beginPath();\n        ctx.fillStyle = \"rgba(255, 255, 255, 0.5)\";\n        ctx.rect(0, 0, 200, 100);\n        ctx.fill();\n        // Draw the text.\n        ctx.fillStyle = \"rgba(50, 50, 0, 1)\";\n        const pvText = `progress value = ${this.progressValue.toFixed(2)}`;\n        ctx.fillText(pvText, 10, 20);\n        const panelText = `active panel = ${this.activePanelIndex}`;\n        ctx.fillText(panelText, 10, 40);\n        const frameText = `frame count = ${this.frameCount}`;\n        ctx.fillText(frameText, 10, 60);\n        // Draw the guideline.\n        ctx.strokeStyle = \"rgba(255, 255, 255, 1.0)\";\n        ctx.beginPath();\n        ctx.moveTo(cbox.left, guideline - 1);\n        ctx.lineTo(cbox.right, guideline - 1);\n        ctx.moveTo(cbox.left, guideline + 1);\n        ctx.lineTo(cbox.right, guideline + 1);\n        ctx.stroke();\n        ctx.strokeStyle = \"rgba(0, 0, 0, 1.0)\";\n        ctx.setLineDash([10, 1]);\n        ctx.beginPath();\n        ctx.moveTo(cbox.left, guideline);\n        ctx.lineTo(cbox.right, guideline);\n        ctx.stroke();\n    }\n}\n"],"sourceRoot":""}